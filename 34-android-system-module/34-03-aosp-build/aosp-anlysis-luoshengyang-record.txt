1. 在Ubuntu上为Android系统编写Linux内核驱动程序 
	1.1 在Ubuntu上为Android系统编写Linux内核驱动程序 
	 五.在hello目录中新增Kconfig和Makefile两个文件，其中Kconfig是在编译前执行配置命令make menuconfig时用到的，而Makefile是执行编译命令make是用到的：

       Kconfig文件的内容

       config HELLO
           tristate "First Android Driver"
           default n
           help
           This is the first android driver.
      Makefile文件的内容
      obj-$(CONFIG_HELLO) += hello.o
      在Kconfig文件中，tristate表示编译选项HELLO支持在编译内核时，hello模块支持以模块、内建和不编译三种编译方法，默认是不编译，因此，在编译内核前，我们还需要执行make menuconfig命令来配置编译选项，使得hello可以以模块或者内建的方法进行编译。
      在Makefile文件中，根据选项HELLO的值，执行不同的编译方法。
      六. 修改arch/arm/Kconfig和drivers/kconfig两个文件，在menu "Device Drivers"和endmenu之间添加一行：
      source "drivers/hello/Kconfig"
        这样，执行make menuconfig时，就可以配置hello模块的编译选项了。. 
      七. 修改drivers/Makefile文件，添加一行：
        obj-$(CONFIG_HELLO) += hello/
      八. 配置编译选项：
        USER-NAME@MACHINE-NAME:~/Android/kernel/common$ make menuconfig
        找到"Device Drivers" => "First Android Drivers"选项，设置为y。
        注意，如果内核不支持动态加载模块，这里不能选择m，虽然我们在Kconfig文件中配置了HELLO选项为tristate。要支持动态加载模块选项，必须要在配置菜单中选择Enable loadable module support选项；在支持动态卸载模块选项，必须要在Enable loadable module support菜单项中，选择Module unloading选项。
      九. 编译：
        USER-NAME@MACHINE-NAME:~/Android/kernel/common$ make
        编译成功后，就可以在hello目录下看到hello.o文件了，这时候编译出来的zImage已经包含了hello驱动。
      十. 参照在Ubuntu上下载、编译和安装Android最新内核源代码（Linux Kernel）一文所示，运行新编译的内核文件，验证hello驱动程序是否已经正常安装：
        USER-NAME@MACHINE-NAME:~/Android$ emulator -kernel ./kernel/common/arch/arm/boot/zImage &
        USER-NAME@MACHINE-NAME:~/Android$ adb shell
        进入到dev目录，可以看到hello设备文件：
        root@android:/ # cd dev
        root@android:/dev # ls
        进入到proc目录，可以看到hello文件：
        root@android:/ # cd proc
        root@android:/proc # ls
        访问hello文件的值：
        root@android:/proc # cat hello
        0
        root@android:/proc # echo '5' > hello
        root@android:/proc # cat hello
        5
        进入到sys/class目录，可以看到hello目录：
        root@android:/ # cd sys/class
        root@android:/sys/class # ls
        进入到hello目录，可以看到hello目录：
        root@android:/sys/class # cd hello
        root@android:/sys/class/hello # ls
        进入到下一层hello目录，可以看到val文件：
        root@android:/sys/class/hello # cd hello
        root@android:/sys/class/hello/hello # ls
        访问属性文件val的值：
        root@android:/sys/class/hello/hello # cat val
        5
        root@android:/sys/class/hello/hello # echo '0'  > val
        root@android:/sys/class/hello/hello # cat val
        0
        至此，我们的hello内核驱动程序就完成了，并且验证一切正常。这里我们采用的是系统提供的方法和驱动程序进行交互，也就是通过proc文件系统和devfs文件系统的方法，下一篇文章中，我们将通过自己编译的C语言程序来访问/dev/hello文件来和hello驱动程序交互，敬请期待。
		————————————————
		版权声明：本文为CSDN博主「罗升阳」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
		原文链接：https://blog.csdn.net/Luoshengyang/article/details/6568411
2. 在Ubuntu上为Android系统内置C可执行程序测试Linux内核驱动程序
	https://blog.csdn.net/luoshengyang/article/details/6571210
	
3. 在Ubuntu上为Android增加硬件抽象层（HAL）模块访问Linux内核驱动程序
	https://blog.csdn.net/luoshengyang/article/details/6573809
	
		进入到在hardware/libhardware/include/hardware目录，新建hello.h文件.
		进入到hardware/libhardware/modules目录，新建hello目录，并添加hello.c文件.
		继续在hello目录下新建Android.mk文件.
	
	3.1 DEVICE_NAME定义为"/dev/hello"。由于设备文件是在内核驱动里面通过device_create创建的，而device_create创建的设备文件默认只有root用户可读写，而hello_device_open一般是由上层APP来调用的，这些APP一般不具有root权限，这时候就导致打开设备文件失败：

      Hello Stub: failed to open /dev/hello -- Permission denied.
      解决办法是类似于Linux的udev规则，打开Android源代码工程目录下，进入到system/core/rootdir目录，里面有一个名为ueventd.rc文件，往里面添加一行：
      /dev/hello 0666 root root
	  
	3.2 *device = &(dev->common); 这个不对吧，应该是这样吧*device = dev 
		一样的，common是dev是第一个成员变量，它们的地址是一样的。
		
	3.3，mkdir: cannot create directory ‘out/target/product’: Permission denied
		eink用户，但out目录为root用户创建的。可以修改文件所属用户及用户组。
		drwxrwxrw-  6 root root  4096 9月  16 08:31 out/
		
		chown -R 所有者用户名.组名 文件夹名称
		例如：chown -R zdz.nginx KooBox
		
4.在Ubuntu为Android硬件抽象层（HAL）模块编写JNI方法提供Java访问硬件服务接口 
	https://blog.csdn.net/luoshengyang/article/details/6575988
	
	4.1,步骤
		4.1.1 进入到frameworks/base/services/jni目录，新建com_android_server_HelloService.cpp文件：
			vi com_android_server_HelloService.cpp
			在com_android_server_HelloService.cpp文件中，实现JNI方法。注意文件的命令方法，com_android_server前缀表示的是包名，表示硬件服务HelloService是放在frameworks/base/services/java目录下的com/android/server目录的，即存在一个命令为com.android.server.HelloService的类。这里，我们暂时略去HelloService类的描述，在下一篇文章中，我们将回到HelloService类来。简单地说，HelloService是一个提供Java接口的硬件访问服务类
		
		