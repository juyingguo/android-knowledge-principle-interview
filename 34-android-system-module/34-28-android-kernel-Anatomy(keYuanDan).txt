1.
10.第10章  AmS内部原理
	10.1.3 
	
		Instrumentation创建流程。
		10.1.3.2  startActivityLocked	
			（7） 步骤详细情况待分析。
		
		10.1.3.3  目标B进程不存在的时候创建进程位置
			ActivityStack.java -> startActivityLocked
				->resumeTopActivityLocked
				
					if (next.app != null && next.app.thread != null) {
						...
					}else{
						...
						startSpecificActivityLocked(next, true, true);
					}
				->startSpecificActivityLocked
				
					if (app != null && app.thread != null) {
						...
					}
					mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,
						"activity", r.intent.getComponent(), false);
		10.1.3.4  
			(11)．应用进程launch指定的Activity
				ActivityThread->main()
					{
						 ActivityThread thread = new ActivityThread();
						thread.attach(false);
					}
				-> attach()
				{
					mgr.attachApplication(mAppThread);
				}
				->ActivityManagerService
					->attachApplication()
					->attachApplicationLocked()
						{
							thread.bindApplication();
							...
							mMainStack.realStartActivityLocked(hr, app, true, true)
						}
					
				->ActivityStack
					->realStartActivityLocked()
					{
						app.thread.scheduleLaunchActivity()
					}
	10.1.6 按“Back”键回到上一个Activity
		在AmS端的finishActivity的执行过程如附图3所示。
		1调用requsetFinishActivityLocked()。
		2判断该Activity是不是最后一个Activity，判断的方法如以下代码所示:
		if (!p.finishing && p != r) {
                lastActivity = false;
                break;
            }
		
		疑问：p.finishing是什么时候赋值的。
			搜索发现有这些：
				ActivityRecord创建时。
				finishActivityLocked(...)函数内部。

