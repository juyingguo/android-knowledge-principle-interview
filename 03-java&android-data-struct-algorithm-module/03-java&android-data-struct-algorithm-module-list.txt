0
0.1 Enjoy LeetCode
	https://blog.csdn.net/foreverling/category_9264622.html 
一、数据结构
1.HashMap、LinkedHashMap、ConcurrentHashMap，在用法和原理上有什么差异，很多公司会考HashMap原理，通过它做一些扩展，比如中国13亿人口年龄的排序问题，年龄对应桶的个数，年龄相同和hash相同问题类似。

2.ArrayList和LinkedList对比，这个相对简单一点。

3.平衡二叉树、二叉查找树、红黑树，这几个我也被考到。

4.Set原理，这个和HashMap考得有点类似，考hash算法相关，被问到过常用hash算法。HashSet内部用到了HashMap

二、关于HashMap数据结构，及我的疑问记录
	2.1、HashMap原理,面试题。      
		
	2.2、HashMap 既然已经继承AbstractMap，为啥还要实现Map
	2.3、HashMap初始容量为什么是2的n次幂及扩容为什么是2倍的形式
	2.4、HashMap容量为2次幂的原因
	2.5、java中：>>>和>>区别
		https://www.cnblogs.com/yulinfeng/p/6602902.html
	2.6、为什么面试要问hashmap 的原理
		https://blog.csdn.net/mbshqqb/article/details/79799009? 
		“你用过HashMap吗？” “什么是HashMap？你为什么用到它？”
		　“你知道HashMap的工作原理吗？” “你知道HashMap的get()方法的工作原理吗？”
		“当两个对象的hashcode相同会发生什么？”
		hashCode()和equals()区别
		string是线程安全的吗
		https://www.cnblogs.com/651434092qq/p/11168608.html
		“当两个对象的hashcode相同会发生什么？”
		两个对象的hashcode相同，两个对象相同吗？为什么？
		
		HashMap的长度
			https://blog.csdn.net/mbshqqb/article/details/79799009
		2.6.5 真正搞懂hashCode和hash算法
			https://blog.csdn.net/qq_33709582/article/details/113337405 
	2.7、HashMap源码深度解析。
		java不同版本代码差异有点多，但原理是否一样呢？
		2.7.1.HashMap深度解析(一)    	
			https://blog.csdn.net/ghsau/article/details/16843543/
			
			a,情景3。bucketindex位置已经存在元素,也就是hash相同.但对象或equals不同时，也会将这个新元素放到这个位置，
				通过一个单链表来维护这种关系
				放在链表表头还是表尾，如何存放？
				分析：根据jdk8源码：java.util.HashMap#putVal
					是放在链表尾部，本质是通过Node的【Node<K,V> next;】指向新的节点。
					根据jdk6源码：java.util.HashMap#put放在表头.即为作为表头,同时next节点指向原数组节点。
			b,hash相同key不同时，这样的节点数据个数达到设定的门限值时就会从将链表转化为树。
				java.util.HashMap#TREEIFY_THRESHOLD
				注释：
				The value must be greater  than 2 and should be at least 8 to mesh with assumptions in  tree removal about conversion back to plain bins upon  shrinkage.
		2.7.2.HashMap深度解析(二)    	
			https://blog.csdn.net/ghsau/article/details/16890151?
			1. ?HashMap所有集合类视图所返回迭代器都是快速失败的(fail-fast)，在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器自身的 remove 或 add 方法，其他任何时间任何方式的修改，迭代器都将抛出 ConcurrentModificationException。
				至于为什么通过迭代器自身的remove或add方法就不会出现这个问题，可以参考我之前的文章List比较好玩的操作中第三个和第四个示例
				https://blog.csdn.net/ghsau/article/details/9347357?
				【详细分析见：四、List集合】
		2.7.3 java.util.HashMap.TreeNode剖析。
			static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V>
		2.7.4 
			JDK 1.8 对HashMap和ConcurrentHashMap的底层数据结构做了修改
			原来 HashMap 的是采用 数组 + 链表，新的HashMap 是 位桶(数组) + 红黑树
		2.7.5 HashMap深度分析 
			https://www.sohu.com/a/153083221_714863?
			https://blog.csdn.net/weixin_34355715/article/details/92253259?
			
		2.7.6 根据Hash值，要找到对应的数组啊，所以对Entry[]的长度length求余，得到的就是Entry数组的index。
			 length为2的n次幂。	
			 static final int hash(Object key) {
				int h;
				return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
			 }
			 
			 计算数组索引即bucketIndex = i = (n - 1) & hash
			 
	2.8、举例，key不同，hash相同的情况，
		参考【2.6.5】中的举例。经过计算处理过的hash相同。
	2.9、10分钟拿下 HashMap
		https://blog.csdn.net/weixin_35586546/article/details/81153793? 
		
		需要注意的是，每次扩容之后，都要重新计算原来的 Entry 在新数组中的位置，为什么数组扩容了，Entry 在数组中的位置发生变化了呢？所以我们会想到计算位置的 indexFor 方法，为什么呢？
		由源码得知，元素所在位置是和数组长度是有关系的，既然扩容后数组长度发生了变化，那么元素位置肯定是要发生变化了
	2.10，为啥HashMap查找和删除元素时最快的？
		
	2.11 java.util.HashMap#transfer
		这个函数内部代码一下子理解不了。
	2.12 java.util.HashMap#getNode
		if (first.hash == hash && // always check first node
                ((k = first.key) == key || (key != null && key.equals(k))))
                return first;
				如何理解(k = first.key) == key || (key != null && key.equals(k)))？
				||两端操作不同？
	2.13 Why hashcode 31? 
		https://blog.csdn.net/ghsau/article/details/21328203? 
		31首先是一个素数，与素数相乘运算后，能降低hashcode碰撞的概率；31其次是一个特殊的值(32-1)，32的二进制是100000，31的二进制是011111，31*N = N << 5 - N，运算速度会快。
		3<<<5-3
		11<<<5 - 11
		1100000 
			11
		10111101
		
		64 + 16 +1
		
		300
		-71
		229
	2.14 resize
		不同版本的jdk版本名称叫法有差异。
		
		2.14.1 
			jdk6为：java.util.HashMap#doubleCapacity
			int highBit = e.hash & oldCapacity;
			假如：oldCapacity = 2^4 = 16
				int newCapacity = oldCapacity * 2 = 2^4 * 2= 2^5 = 16*2 = 32
				int highBit = e.hash & oldCapacity;//e.hash&10000 ,这样的话得到的值重复会很多的。为1或0
				newTable[j | highBit] = e;//
				if = highBit = 0;
				if = highBit = 1;
				j = 0,1,10,11,100,101,110,111...
				j = 0;j | highBit = 0或1
				j = 1;j | highBit = 1
				j = 10;j | highBit = 10或11
				j = 11;j | highBit = 11
				j = 100;j | highBit = 100或101
				j = 101;j | highBit = 101
				j = 110;j | highBit = 110或111
				j = 111;j | highBit = 111
				
				初步猜测规律：最多index两个两个相同。
				
				随后判断e对应的链表。
				j = 0;j | highBit = 0或1
				highBit = 0
					nextHighBit = n.hash & oldCapacity;// 0或1
					if nextHighBit = 0;
						highBit = nextHighBit
					if nextHighBit = 1;
						highBit != nextHighBit
							
						if (broken == null)
							newTable[j | nextHighBit] = n;//j | nextHighBit = 1
						else
							broken.next = n;
				highBit = 1
				
				j = 1;j | highBit = 1
		2.14.2 
			android-sdk25,jdk8
			java.util.HashMap#resize
				
三、HashMap和Hashtable区别？

	这个一定要去看源码！看源码！看源码！实在看不下去的可以上网看别人的分析。简单总结有几点：

	1.HashMap支持null Key和null Value；Hashtable不允许。这是因为HashMap对null进行了特殊处理，将null的hashCode值定为了0，从而将其存放在哈希表的第0个bucket。

	2.HashMap是非线程安全，HashMap实现线程安全方法为Map map = Collections.synchronziedMap(new HashMap())；Hashtable是线程安全

	3.HashMap默认长度是16，扩容是原先的2倍；Hashtable默认长度是11，扩容是原先的2n+1

	4.HashMap继承AbstractMap；Hashtable继承了Dictionary?

	扩展，HashMap 对比 ConcurrentHashMap ，HashMap 对比 SparseArray，LinkedArray对比ArrayList，ArrayList对比Vector
	--------------------- 
	作者：huison_ma 
	来源：CSDN 
	原文：https://blog.csdn.net/qq_27053103/article/details/79564062 
	版权声明：本文为博主原创文章，转载请附上博文链接！
四、List集合。
	4.1、至于为什么通过迭代器自身的remove或add方法就不会出现这个问题，可以参考我之前的文章List比较好玩的操作中第三个和第四个示例
			https://blog.csdn.net/ghsau/article/details/9347357
		4.1.1、普通for循环与for循环增强区别，底层原理？
			Java中的增强for循环的实现原理与坑
			https://blog.csdn.net/john1337/article/details/79925809
			
			从字节码看Java中for-each循环（增强for循环）实现原理
			https://blog.csdn.net/u011392897/article/details/54562596
		4.1.2.for循环增强遍历，会抛出ConcurrentModificationException，原因，底层原理？
			1.在遍历删除操作第几个元素的是否发生ConcurrentModificationException。
		4.1.3、Iterator是工作在一个独立的线程中，并且拥有一个 mutex 锁。
	
五、集合中用到的锁。
	5.1、Iterator是工作在一个独立的线程中，并且拥有一个 mutex 锁。
	
	
六、LinkedList

	https://blog.csdn.net/gongchuangsu/article/details/51527042	?

	LinkedList 是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。
	LinkedList 实现 List 接口，能进行队列操作。
	LinkedList 实现 Deque 接口，即能将LinkedList当作双端队列使用。
	ArrayList底层是由数组支持，而LinkedList 是由双向链表实现的，其中的每个对象包含数据的同时还包含指向链表中前一个与后一个元素的引用。

	--------------------- 
	作者：键盘舞者113 
	来源：CSDN 
	原文：https://blog.csdn.net/z979451341/article/details/79380704 
	版权声明：本文为博主原创文章，转载请附上博文链接！
七、HashTable
	https://blog.csdn.net/jinhuoxingkong/article/details/52022999

	Hashtable和HashMap到底有哪些不同呢

（1）基类不同：HashTable基于Dictionary类，而HashMap是基于AbstractMap。Dictionary是什么？它是任何可将键映射到相应值的类的抽象父类，而AbstractMap是基于Map接口的骨干实现，它以最大限度地减少实现此接口所需的工作。

（2）null不同：HashMap可以允许存在一个为null的key和任意个为null的value，但是HashTable中的key和value都不允许为null。

（3）线程安全：HashMap时单线程安全的，Hashtable是多线程安全的。

（4）遍历不同：HashMap仅支持Iterator的遍历方式，Hashtable支持Iterator和Enumeration两种遍历方式。
	
（1）Hashtable 是一个散列表，它存储的内容是键值对(key-value)映射。

	（2）Hashtable?继承于Dictionary，实现了Map、Cloneable、java.io.Serializable接口。

	（3）Hashtable 的函数都是同步的，这意味着它是线程安全的。它的key、value都不可以为null。
	--------------------- 
	作者：劲火星空 
	来源：CSDN 
	原文：https://blog.csdn.net/jinhuoxingkong/article/details/52022999 
	版权声明：本文为博主原创文章，转载请附上博文链接！
八、ConcurrentHashMap
	8.1、Java的ConcurrentHashMap的实现原理
		Java5中的ConcurrentHashMap，线程安全，设计巧妙，用桶粒度的锁，避免了put和get中对整个map的锁定，尤其在get中，只对一个HashEntry做锁定操作，性能提升是显而易见的。
	8.2、ConcurrentHashMap之实现细节
		https://www.iteye.com/topic/344876
九、Map 与Dictionary区别，原理？
	Map是"key-value键值对"接口，Dictionary是声明了操作"键值对"函数接口的抽象类。 
十、Java 中的 ==, equals 与 hashCode 的区别与联系
	https://blog.csdn.net/SongYuxinIT/article/details/81911645
	https://blog.csdn.net/E01014165/article/details/52173927
	https://blog.csdn.net/justloveyou_/article/details/52464440
	https://blog.csdn.net/afgasdg/article/details/6889383

十一、Hashtable和ConcurrentHashMap的区别
	11.1、https://blog.csdn.net/weixin_39651041/article/details/79953811
	
十二、Queue与Deque区别

十三、CopyOnWriteArrayList 使用及与原理。
	
十四、链表
	
	14.1、【数据结构】链表的原理及java实现 
		https://blog.csdn.net/jianyuerensheng/article/details/51200274
	
	14.2、用java简单的实现单链表的基本操作 
		https://blog.csdn.net/tayanxunhua/article/details/11100097
	
	14.3、链表基础知识总结 
		https://blog.csdn.net/u012531536/article/details/80170893
		
	14.4、数据结构-线性表(顺序表与链表的基本知识 以及ArrayList 源码分析) 
		https://cloud.tencent.com/developer/article/1334670
	
	14.4、链表头插法及尾插法？
	
	14.5 对数组排序，与对链表排序，时间对比 
		1. 对LinkedList进行排序
			https://blog.csdn.net/u014230945/article/details/68065594
			
	
十五、ArrayMap?
	
	15.1、面试必备：ArrayMap源码解析 
		https://www.jianshu.com/p/1fb660978b14
		
十六、ArrayList
	16.1 阿里面试，面试官没想到一个ArrayList，我都能跟他扯半小时  
		https://blog.csdn.net/qq_35190492/article/details/103883964?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendHotData-15&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendHotData-15 
	16.2 ArrayList循环遍历并删除元素的几种情况 
		https://www.cnblogs.com/51life/p/10406662.html 
		
		ArrayList循环遍历并删除元素的常见陷阱
		https://www.cnblogs.com/huangjinyong/p/9455163.html 
		
17 LinkedHashMap
	17.0 test project in:
		com.datastructtest.LinkedHashMapTest
	17.1 的accessOrder的作用
		https://blog.csdn.net/weixin_34248118/article/details/92523099
		
	17.2 java.util.LinkedHashMap#afterNodeAccess(Node<K,V> e)中，传递参数的e的before,after是否有值。
		java.util.LinkedHashMap#get //调用者。
		根据三个集合中三个数据节点。先根据不同位置，模拟分析。【当前初步判断，可以进一步验证】是有值的。具体值是否为null，是根据e在集合中的位置而定。
	17.3 理解LinkedHashMap
		https://www.cnblogs.com/children/archive/2012/10/02/2710624.html 
		
		讲解对应android-25源码
18 LruCache
	3.1 test project all:
		com.algorithm.lrutest.LRUCacheTest
	3.2 Android照片墙完整版，完美结合LruCache和DiskLruCache
		https://guolin.blog.csdn.net/article/details/34093441 
		
	3.3 :LRU算法面试。
		
		3.3.1 大厂面试必备:LRU算法-删除最近最未少使用算法(详细附源代码)
			https://blog.csdn.net/qq_41066066/article/details/106982229? 
			【27-develop-person.txt，1.5、强子播客】
			code:
			https://github.com/memo012/java_memo
			
			算法设计思路
			LRU 缓存机制可以通过哈希表辅以双向链表实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对。

			双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。

			哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。
			————————————————
	3.4 Android——LruCache源码解析
		https://blog.csdn.net/weixin_33869377/article/details/91371913 
		https://blog.csdn.net/u010983881/article/details/79050209? 