一、单例模式。
	1.1、使用volatile修饰，禁止指令重排序。
		static volatile EventBus defaultInstance; defaultInstance
		public static EventBus getDefault() {
				if (defaultInstance == null) {
					synchronized (EventBus.class) {
						if (defaultInstance == null) {
							defaultInstance = new EventBus();
						}
					}
				}
				return defaultInstance;
			}
	1.2、使用volatile修饰与不使用的区别？
	
	1.3、单例模式：好几种写法，要求会手写，分析优劣。一般双重校验锁中用到volatile，需要分析volatile的原理
		
		java单例双重检查锁为什么需要加volatile关键字
		https://blog.csdn.net/zcl_love_wx/article/details/80758162
		
		java单例双重检查锁为什么需要加volatile关键字
		https://blog.csdn.net/xiakepan/article/details/52444565
		
		JAVA设计模式之单例模式
		https://blog.csdn.net/jason0539/article/details/23297037/
		
		今天再看这段话有些歧义。假设没有关键字volatile的情况下，两个线程A、B，都是第一次调用该单例方法，线程A先执行instance = new Instance()，
		该构造方法是一个非原子操作，编译后生成多条字节码指令，由于JAVA的指令重排序，可能会先执行instance的赋值操作，该操作实际只是在内存中开辟一片存储对象的区域后直接返回内存的引用，
		之后instance便不为空了，但是实际的初始化操作却还没有执行，如果就在此时线程B进入，
		就会看到一个不为空的但是不完整（没有完成初始化）的Instance对象，所以需要加入volatile关键字，禁止指令重排序优化，从而安全的实现单例。
		
		正解，创建对象可以分解为如下的3行伪代码
		memory=allocate(); //1:分配对象的内存空间
		ctorInstance(memory); //2:初始化对象
		instance=memory; //3:设置instance指向刚分配的内存地址上面3行代码中的2和3之间，可能会被重排序导致先3后2,
